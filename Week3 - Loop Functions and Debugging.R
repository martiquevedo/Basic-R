
# WEEK 3 FUNCTION APPLY ####


# lapply, loop over the list of objects and apply a function to every element of that list.
# 
# lapply (x, FUN, ...)
  # where x is the object (list or be coerced into list)
  # FUN is the name of a function
  # and ... is the extra arguments for the function (note that they can be default)
# BUT So lapply and the associated functions make heavy use of what, of what are called anonymous functions. 
# Anonymous functions are functions that don't have names, so you don't assign them a name of some sort
# but you can kind of generate them on the fly.



# Sapply is a variant of lapply that simplifies the results. 
  # if the result of the function in each element of the list produces a vector of length 1, it will merge all resulting elements into 1 single vector
  # (instead of a list of 1 length vectors)
  # if the resulting elements of the function are the same length it will make a matrix, etc.

# Apply is a function that operates over the margins of an array. So, this is very useful if you want to take summaries of matrices or other or, higher dimensional arrays. 
  # first argument acts as an array. An array is a vector that has dimensions attached to it. So a matrix is a two dimensional array, for example.
  # A margin, is is a vector, an integer vector that indicates which margin (or dimension) should be retained.


# Tapply is short for table apply. And, it applies a function over subsets of a vector. 


# And mapply is a multivariate apply of sort which applies a function in parallel over a set of arguments

# split takes a vector or other objects and splits it into groups determined by a factor or list of factors

#SWIRL
## lapply and sapply #### 

# the unique() function returns a vector with all duplicate elements removed.

# Flags dataset contains details of various nations and their flags.
# Columns 11 through 17 of our dataset are indicator variables, each representing a different color.
# We want to know the total number of countries that have a particular color on their flag
flag_colors <- flags[,11:17] #subset of color columns
lapply (flag_colors, sum) # provides a list, each entry is 1 color and number of countries with a flag of that color
sapply (flag_colors, sum) # same but simplifying into a vector

unique_vals <- lapply(flags, unique) #provides the unique values for each variable in the flags dataset

#if we would only be interested in the second item from each element of the unique_vals list we can create our own function inside lapply:

lapply(unique_vals, function(elem) elem[2]) # our | function takes one argument, elem, which is just a 'dummy variable' 
                                            # that takes on the value of each element of unique_vals, in turn.




## vapply and tapply
vapply(flags, unique, numeric(1)) # you expect each element of the result to be a numeric vector of length 1


# DEBUGGING

# Indications that something's not right
  # message: A generic notification/diagnostic message produced by the message function;
  #           execution of the function continues
  # warning: An indication that something is wrong but not necessarily fatal; execution of the
  #           function continues; generated by the warning function
  # error: An indication that a fatal problem has occurred; execution stops; 
  #         produced by the stop function
  # condition: A generic concept for indicating that something unexpected can occur; programmers
  #             can create their own conditions


# How do you know that something is wrong with your function?
  #   What was your input? How did you call the function?
  #   What were you expecting? Output, messages, other results?
  #   What did you get?
  #   How does what you get differ from what you were expecting?
  #   Were your expectations correct in the first place?
  #   Can you reproduce the problem (exactly)?